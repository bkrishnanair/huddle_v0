rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection
    match /users/{userId} {
      // Users can read their own profile, and other users can read public profiles
      allow read: if request.auth != null;
      // Users can only write to their own profile
      allow write: if request.auth != null && request.auth.uid == userId;

      // Connections subcollection
      match /connections/{connectionId} {
        // A user can read their own connections list
        allow read: if request.auth != null && request.auth.uid == userId;

        // A user can create a connection document in another user's subcollection (send a request)
        // A user can also update their own connection document (accept a request)
        allow write: if request.auth != null && 
          (
            // Case 1: Sending a request
            // The connectionId is the ID of the user sending the request
            (request.auth.uid == connectionId && request.resource.data.status == 'pending') ||
            // Case 2: Accepting a request
            // The userId is the ID of the user accepting the request
            (request.auth.uid == userId && request.resource.data.status == 'accepted')
          );
      }
    }
    
    // Events collection
    match /events/{eventId} {
      // Allow public read access for viewing events on the map
      allow read: if true;
      
      // Only authenticated users can create events
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.createdBy;
      
      allow update: if request.auth != null && (
        // Event organizer can update any field
        request.auth.uid == resource.data.createdBy ||
        // Regular players can only update players and currentPlayers (for RSVP)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['players', 'currentPlayers'])) ||
        // Only organizer can update checkedInPlayers array
        (request.auth.uid == resource.data.createdBy && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['checkedInPlayers']))
      );
      
      // Only the event creator can delete events
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.createdBy;
      
      // Chat subcollection for each event
      match /chat/{messageId} {
        // Only event participants can read chat messages
        allow read: if request.auth != null 
          && isEventParticipant(eventId);
        
        allow create: if request.auth != null
          && isEventParticipant(eventId)
          && request.auth.uid == request.resource.data.senderId;
        
        allow delete: if request.auth != null 
          && request.auth.uid == resource.data.senderId;
      }
    }
    
    function isEventParticipant(eventId) {
      let eventData = get(/databases/$(database)/documents/events/$(eventId)).data;
      return request.auth.uid == eventData.createdBy 
        || request.auth.uid in eventData.players;
    }
  }
}
